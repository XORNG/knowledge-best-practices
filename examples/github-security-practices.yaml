name: GitHub Repository Security
version: "1.0"
language: general
description: |
  Best practices for securing GitHub repositories, CI/CD pipelines,
  and implementing automated security scanning. These practices help
  protect codebases from vulnerabilities and ensure secure development workflows.

practices:
  # ==========================================================================
  # DEPENDABOT CONFIGURATION
  # ==========================================================================
  - id: enable-dependabot-alerts
    title: Enable Dependabot alerts and security updates
    description: |
      Configure Dependabot to automatically detect vulnerabilities in your
      dependencies and create pull requests to update them. This is the first
      line of defense against known vulnerabilities in third-party code.
    category: security
    severity: error
    goodExample: |
      # .github/dependabot.yml
      version: 2
      updates:
        - package-ecosystem: "npm"
          directory: "/"
          schedule:
            interval: "weekly"
            day: "monday"
            time: "09:00"
          open-pull-requests-limit: 10
          commit-message:
            prefix: "deps"
            include: "scope"
          labels:
            - "dependencies"
            - "security"
          groups:
            # Group minor and patch updates together
            production:
              dependency-type: "production"
              update-types:
                - "minor"
                - "patch"
            dev-dependencies:
              dependency-type: "development"
              update-types:
                - "minor"
                - "patch"
        
        # Also scan GitHub Actions
        - package-ecosystem: "github-actions"
          directory: "/"
          schedule:
            interval: "weekly"
    badExample: |
      # No dependabot.yml file means no automated vulnerability scanning
      # or dependency updates. Manual dependency management is error-prone
      # and vulnerabilities can go unnoticed for months.
    rationale: |
      According to GitHub's security research, over 80% of security vulnerabilities
      in modern applications come from dependencies. Dependabot automates the
      process of keeping dependencies updated and alerts you to known vulnerabilities,
      significantly reducing your attack surface.
    tags:
      - dependencies
      - automation
      - supply-chain

  - id: group-dependabot-updates
    title: Group Dependabot updates to reduce PR noise
    description: |
      Configure Dependabot groups to combine related dependency updates
      into single pull requests, reducing noise while maintaining security.
    category: security
    severity: warning
    goodExample: |
      # Group TypeScript-related updates together
      groups:
        typescript:
          patterns:
            - "typescript"
            - "@types/*"
            - "ts-*"
          update-types:
            - "minor"
            - "patch"
        
        # Group testing libraries
        testing:
          patterns:
            - "jest"
            - "@jest/*"
            - "vitest"
            - "@testing-library/*"
          update-types:
            - "minor"
            - "patch"
    badExample: |
      # Without grouping, you might get 20+ PRs for minor updates
      # to related packages, overwhelming reviewers and slowing down
      # the merge process.
    rationale: |
      Grouped updates maintain security while being practical. Teams are more
      likely to promptly review and merge a single "TypeScript ecosystem update"
      PR than 15 individual @types/* package updates.
    tags:
      - dependencies
      - workflow

  # ==========================================================================
  # CODEQL AND SAST
  # ==========================================================================
  - id: enable-codeql-scanning
    title: Enable CodeQL security scanning for code
    description: |
      Use GitHub's CodeQL to perform semantic code analysis, detecting
      security vulnerabilities, bugs, and code quality issues that static
      linters miss.
    category: security
    severity: error
    goodExample: |
      # .github/workflows/security.yml
      name: Security Scanning
      
      on:
        push:
          branches: [main, develop]
        pull_request:
          branches: [main, develop]
        schedule:
          # Weekly scan on Monday at midnight
          - cron: '0 0 * * 1'
      
      permissions:
        contents: read
        security-events: write
        actions: read
      
      jobs:
        codeql-analysis:
          name: CodeQL Analysis
          runs-on: ubuntu-latest
          timeout-minutes: 360
          
          strategy:
            fail-fast: false
            matrix:
              language: ['javascript-typescript']
          
          steps:
            - name: Checkout repository
              uses: actions/checkout@v4
            
            - name: Initialize CodeQL
              uses: github/codeql-action/init@v3
              with:
                languages: ${{ matrix.language }}
                # Extended queries for more comprehensive analysis
                queries: +security-extended,security-and-quality
            
            - name: Autobuild
              uses: github/codeql-action/autobuild@v3
            
            - name: Perform CodeQL Analysis
              uses: github/codeql-action/analyze@v3
              with:
                category: "/language:${{ matrix.language }}"
    badExample: |
      # No security scanning means vulnerabilities like:
      # - SQL injection
      # - Cross-site scripting (XSS)
      # - Path traversal
      # - Insecure cryptography
      # Can slip through code review undetected.
    rationale: |
      CodeQL uses semantic analysis to understand code flow, detecting complex
      vulnerabilities that simple pattern matching misses. It can trace data
      from untrusted sources through your code to find injection vulnerabilities.
    tags:
      - sast
      - vulnerabilities
      - code-quality

  - id: dependency-review-on-pr
    title: Require dependency review on pull requests
    description: |
      Block PRs that introduce dependencies with known vulnerabilities
      or unacceptable licenses before they're merged.
    category: security
    severity: error
    goodExample: |
      # Add to your security workflow
      dependency-review:
        name: Dependency Review
        runs-on: ubuntu-latest
        if: github.event_name == 'pull_request'
        
        steps:
          - name: Checkout repository
            uses: actions/checkout@v4
          
          - name: Dependency Review
            uses: actions/dependency-review-action@v4
            with:
              # Block high and critical severity vulnerabilities
              fail-on-severity: high
              # Check license compliance
              deny-licenses: GPL-3.0, AGPL-3.0
              allow-ghsas: false
    badExample: |
      # Without dependency review, a PR could introduce a vulnerable
      # package version, and you wouldn't know until Dependabot alerts
      # you days or weeks later - after the code is in production.
    rationale: |
      Shift-left security: catching vulnerable dependencies before merge
      is far cheaper and safer than patching in production. License compliance
      also protects your project from legal issues.
    tags:
      - dependencies
      - supply-chain
      - compliance

  # ==========================================================================
  # SECRET SCANNING
  # ==========================================================================
  - id: enable-secret-scanning
    title: Enable secret scanning to prevent credential leaks
    description: |
      Use automated tools to detect accidentally committed secrets like
      API keys, tokens, and passwords before they reach the repository.
    category: security
    severity: error
    goodExample: |
      # Add to your security workflow
      secret-scanning:
        name: Secret Scanning
        runs-on: ubuntu-latest
        
        steps:
          - name: Checkout repository
            uses: actions/checkout@v4
            with:
              fetch-depth: 0  # Full history for thorough scanning
          
          - name: TruffleHog Secret Scan
            uses: trufflesecurity/trufflehog@main
            with:
              path: ./
              base: ${{ github.event.repository.default_branch }}
              head: HEAD
              extra_args: --only-verified
      
      # Also enable GitHub's native secret scanning in repo settings:
      # Settings > Security > Secret scanning
    badExample: |
      # .env file accidentally committed
      OPENAI_API_KEY=sk-abcdef123456789...
      DATABASE_URL=postgres://user:password@host/db
      AWS_SECRET_ACCESS_KEY=...
      
      # Even if deleted, secrets remain in git history forever
      # unless you force-push with history rewriting.
    rationale: |
      Exposed secrets are one of the most common and costly security incidents.
      GitHub reports that thousands of credentials are exposed daily. Once a
      secret is in git history, it's very difficult to remove and should be
      considered compromised.
    tags:
      - secrets
      - credentials
      - prevention

  - id: use-environment-secrets
    title: Use GitHub Secrets for sensitive configuration
    description: |
      Store sensitive values like API keys and credentials in GitHub Secrets
      rather than in code or configuration files.
    category: security
    severity: error
    goodExample: |
      # In your workflow, reference secrets:
      - name: Deploy
        env:
          API_KEY: ${{ secrets.API_KEY }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          npm run deploy
      
      # For organization-wide secrets, use organization secrets
      # For environment-specific secrets, use environment secrets
      
      # In your code, read from environment:
      const apiKey = process.env.API_KEY;
      if (!apiKey) {
        throw new Error('API_KEY environment variable is required');
      }
    badExample: |
      # Hard-coded secrets in code
      const client = new OpenAI({
        apiKey: 'sk-abcdef123456789...',  // NEVER do this
      });
      
      # Or in configuration files
      // config.json
      {
        "apiKey": "sk-abcdef123456789..."
      }
    rationale: |
      GitHub Secrets are encrypted, only exposed to workflows that need them,
      and never appear in logs. Hard-coded secrets can be extracted from
      compiled code, exposed in logs, and will be in your git history forever.
    tags:
      - secrets
      - configuration
      - best-practices

  # ==========================================================================
  # WORKFLOW SECURITY
  # ==========================================================================
  - id: pin-action-versions
    title: Pin GitHub Actions to specific versions or SHAs
    description: |
      Always pin GitHub Actions to a specific version or commit SHA to prevent
      supply chain attacks through compromised or malicious action updates.
    category: security
    severity: error
    goodExample: |
      steps:
        # Best: Pin to commit SHA for security-critical actions
        - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
        
        # Good: Pin to major version for maintained actions
        - uses: actions/setup-node@v4
          with:
            node-version: '20'
        
        # Enable Dependabot for github-actions to get automatic updates
        # .github/dependabot.yml
        - package-ecosystem: "github-actions"
          directory: "/"
          schedule:
            interval: "weekly"
    badExample: |
      steps:
        # DANGEROUS: Using @main can pull malicious code
        - uses: some-org/some-action@main
        
        # RISKY: Even @latest can be compromised
        - uses: some-org/some-action@latest
    rationale: |
      In supply chain attacks, malicious code can be injected into a GitHub
      Action. If you use @main or @latest, that malicious code will automatically
      run in your workflow. Pinning to a SHA ensures you use exactly the code
      you've reviewed.
    tags:
      - supply-chain
      - ci-cd
      - actions

  - id: minimal-workflow-permissions
    title: Use minimal permissions in GitHub Actions workflows
    description: |
      Apply the principle of least privilege to workflow permissions.
      Only request the permissions your workflow actually needs.
    category: security
    severity: error
    goodExample: |
      # At the workflow level, set restrictive defaults
      permissions:
        contents: read
      
      jobs:
        build:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            # ... build steps
        
        # Only the job that needs write access gets it
        deploy:
          runs-on: ubuntu-latest
          permissions:
            contents: write
            packages: write
          steps:
            - uses: actions/checkout@v4
            # ... deploy steps
    badExample: |
      # DANGEROUS: Full permissions for everything
      permissions: write-all
      
      # Or not specifying permissions at all, which may use
      # the repository's default (often too permissive)
    rationale: |
      If a workflow is compromised (through a malicious dependency, action,
      or code injection), limiting permissions constrains what the attacker
      can do. A read-only workflow can't push malicious code or modify releases.
    tags:
      - permissions
      - ci-cd
      - least-privilege

  - id: protect-workflow-secrets
    title: Protect secrets from untrusted code in workflows
    description: |
      Be careful about which events and contexts have access to secrets,
      especially in pull request workflows from forks.
    category: security
    severity: error
    goodExample: |
      # For PR checks from forks, use pull_request (not pull_request_target)
      # pull_request runs with fork's permissions, no access to secrets
      on:
        pull_request:
          branches: [main]
      
      # If you MUST use pull_request_target (for label-based workflows):
      on:
        pull_request_target:
          types: [labeled]
      
      jobs:
        safe-job:
          # Only run after manual approval via label
          if: contains(github.event.pull_request.labels.*.name, 'safe-to-test')
          runs-on: ubuntu-latest
          steps:
            # NEVER checkout PR code when using pull_request_target
            - uses: actions/checkout@v4
              with:
                ref: ${{ github.event.repository.default_branch }}
    badExample: |
      # DANGEROUS: Running PR code with access to secrets
      on:
        pull_request_target:
      
      jobs:
        dangerous-job:
          runs-on: ubuntu-latest
          steps:
            # This checks out attacker-controlled code
            - uses: actions/checkout@v4
              with:
                ref: ${{ github.event.pull_request.head.sha }}
            
            # And runs it with access to secrets!
            - run: npm test
              env:
                SECRET_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
    rationale: |
      The pull_request_target event runs with repository secrets in the context
      of the base repository. If you checkout and run code from the PR, an
      attacker can extract secrets by modifying the workflow or test files.
    tags:
      - ci-cd
      - secrets
      - pull-requests

  # ==========================================================================
  # DOCKER SECURITY
  # ==========================================================================
  - id: scan-container-images
    title: Scan Docker images for vulnerabilities
    description: |
      Use container scanning tools like Trivy to detect vulnerabilities
      in your Docker images before deployment.
    category: security
    severity: error
    goodExample: |
      # Add to your CI/CD workflow
      docker-security:
        name: Docker Security Scan
        runs-on: ubuntu-latest
        
        steps:
          - name: Checkout repository
            uses: actions/checkout@v4
          
          - name: Build Docker image
            run: docker build -t myapp:scan .
          
          - name: Run Trivy vulnerability scanner
            uses: aquasecurity/trivy-action@master
            with:
              image-ref: 'myapp:scan'
              format: 'sarif'
              output: 'trivy-results.sarif'
              severity: 'CRITICAL,HIGH'
          
          - name: Upload Trivy scan results
            uses: github/codeql-action/upload-sarif@v3
            if: always()
            with:
              sarif_file: 'trivy-results.sarif'
    badExample: |
      # Building and deploying without scanning
      - name: Build and push
        run: |
          docker build -t myimage .
          docker push myimage:latest  # Could contain critical vulnerabilities!
    rationale: |
      Container images can contain vulnerable system packages, outdated runtimes,
      and misconfigured services. Scanning catches these before deployment.
      The SARIF upload integrates findings with GitHub's security dashboard.
    tags:
      - docker
      - containers
      - scanning

  - id: use-minimal-base-images
    title: Use minimal base images for Docker containers
    description: |
      Choose minimal base images like Alpine or distroless to reduce
      attack surface and vulnerability count.
    category: security
    severity: warning
    goodExample: |
      # Use multi-stage builds with minimal final image
      FROM node:20 AS builder
      WORKDIR /app
      COPY package*.json ./
      RUN npm ci
      COPY . .
      RUN npm run build
      
      # Production image - minimal
      FROM node:20-alpine AS production
      WORKDIR /app
      
      # Don't run as root
      USER node
      
      COPY --from=builder --chown=node:node /app/dist ./dist
      COPY --from=builder --chown=node:node /app/node_modules ./node_modules
      
      CMD ["node", "dist/index.js"]
    badExample: |
      # Full Ubuntu image has many more packages and vulnerabilities
      FROM ubuntu:latest
      RUN apt-get update && apt-get install -y nodejs npm
      COPY . .
      RUN npm install
      CMD ["npm", "start"]
      
      # Running as root by default
      # Contains hundreds of unused packages
    rationale: |
      Alpine images have ~5MB compared to ~100MB+ for Ubuntu/Debian. Fewer
      packages means fewer potential vulnerabilities and smaller attack surface.
      Running as non-root prevents container escape privilege escalation.
    tags:
      - docker
      - containers
      - hardening

  # ==========================================================================
  # BRANCH PROTECTION
  # ==========================================================================
  - id: require-pr-reviews
    title: Require pull request reviews before merging
    description: |
      Configure branch protection rules to require code reviews,
      preventing direct pushes to protected branches.
    category: security
    severity: error
    goodExample: |
      # Via GitHub UI or API:
      # Settings > Branches > Add branch protection rule
      #
      # Configure:
      # - Require a pull request before merging
      # - Require approvals: 1 (or more for critical repos)
      # - Dismiss stale pull request approvals when new commits are pushed
      # - Require review from Code Owners
      # - Require approval of the most recent reviewable push
      
      # CODEOWNERS file for automatic review assignment
      # .github/CODEOWNERS
      * @team/core-maintainers
      /security/ @team/security
      *.yml @team/devops
    badExample: |
      # No branch protection allows:
      # - Direct pushes to main (including malicious code)
      # - Force pushes (rewriting history)
      # - Bypassing code review
      # - No required status checks
    rationale: |
      Code review catches bugs and security issues. Required reviews ensure
      no code reaches production without at least one other person examining it.
      CODEOWNERS ensures the right experts review changes to sensitive areas.
    tags:
      - branch-protection
      - code-review
      - access-control

  - id: require-status-checks
    title: Require status checks before merging
    description: |
      Configure branch protection to require passing CI checks,
      including security scans, before PRs can be merged.
    category: security
    severity: error
    goodExample: |
      # In branch protection rules, require these status checks:
      # - CodeQL Analysis
      # - Dependency Review
      # - npm Security Audit
      # - Build
      # - Tests
      
      # Your workflow names become the status checks
      name: Security Scanning  # This becomes a required check
      
      on:
        pull_request:
          branches: [main]
      
      jobs:
        codeql-analysis:  # job name appears in status
          # ...
    badExample: |
      # Without required status checks:
      # - PRs can be merged with failing tests
      # - Security vulnerabilities go undetected
      # - Broken code reaches production
    rationale: |
      Required status checks are your automated gatekeeper. They ensure that
      security scanning, tests, and other quality checks pass before code
      can be merged, preventing known issues from reaching production.
    tags:
      - branch-protection
      - ci-cd
      - quality-gates

  # ==========================================================================
  # SUPPLY CHAIN SECURITY
  # ==========================================================================
  - id: use-lockfiles
    title: Use and commit dependency lockfiles
    description: |
      Always use lockfiles (package-lock.json, yarn.lock, pnpm-lock.yaml)
      and commit them to ensure reproducible builds and prevent supply chain attacks.
    category: security
    severity: error
    goodExample: |
      # package-lock.json should be committed
      # Use npm ci in CI (respects lockfile exactly)
      
      - name: Install dependencies
        run: npm ci  # NOT npm install
      
      # .gitignore should NOT include lockfiles
      # Correct:
      node_modules/
      
      # Incorrect:
      # package-lock.json  # Don't ignore this!
    badExample: |
      # Ignoring lockfile
      # .gitignore
      package-lock.json  # BAD - allows dependency attacks
      
      # Using npm install in CI (ignores lockfile versions)
      - run: npm install  # BAD - can install different versions
    rationale: |
      Lockfiles pin exact dependency versions and their integrity hashes.
      Without them, `npm install` could fetch a compromised package version.
      `npm ci` fails if package.json and lockfile don't match, ensuring
      you always get exactly the dependencies you tested.
    tags:
      - dependencies
      - supply-chain
      - reproducibility

  - id: audit-dependencies-regularly
    title: Regularly audit and update dependencies
    description: |
      Run security audits on dependencies and promptly address vulnerabilities.
      Don't let security updates accumulate.
    category: security
    severity: error
    goodExample: |
      # In CI, run audits and fail on high severity
      - name: Run npm audit
        run: npm audit --audit-level=high
      
      # Generate report for tracking
      - name: Generate audit report
        run: npm audit --json > npm-audit-report.json
        continue-on-error: true
      
      - name: Upload audit report
        uses: actions/upload-artifact@v4
        with:
          name: npm-audit-report
          path: npm-audit-report.json
      
      # Regularly check for updates
      - name: Check for outdated packages
        run: npm outdated || true
    badExample: |
      # Ignoring audit findings
      npm audit  # Shows 10 high severity vulnerabilities
      # Developer: "We'll fix those later"
      # 6 months pass...
      npm audit  # Shows 50 vulnerabilities
      # "It's too much work now"
    rationale: |
      Security debt compounds. A vulnerability fixed this week is a quick PR.
      A hundred vulnerabilities fixed in 6 months might require a major
      refactoring effort and extensive testing. Stay on top of updates.
    tags:
      - dependencies
      - maintenance
      - technical-debt
